#' Generate sanitized proportions that satisfy (epsilon,delta)-DP
#'
#' @param hist.df a data.frame of the counts for the number of occurrences of a category
#'    (or combination of categories) which includes the column \code{hist.df$Freq} and columns
#'    for the possible categorical (or discretized continuous) columns.
#' @param epsilon a positive privacy parameter value
#' @param delta a non-negative value for a privacy parameter.
#' @param possible.combos a integer value of the number of possible combinations of column values.
#'    If \code{possible.combos=NULL} (default), then it is assumed all possible combinations
#'    are represented in \code{hist.df}.
#' @param sensitivity.multiplier a positive value to such that the sensitivity is
#'    \code{sensitivity.multiplier} over the number of rows in the confidential dataset. Default is 2 for bounded DP setting.
#' @param quietly a logical to indicate if messages should be suppressed.
#' @return a data.frame which is the hist.df with column \code{hist.df$san.prop} which
#'    is a sanitized proportion of the data that is in a bin which is generated by a
#'    Laplace mechanism satisfying (\code{epsilon},\code{delta})-differential privacy.
#'
#' @examples
#' freq.df=multivariate_histogram(mtcars[,2:4],continuous.vars=c("disp","hp"),num.bin=3)
#' dp_perturbed_hist(freq.df,0.9,delta=0.01)
#'
#' @references
#' When \code{delta==0} or \code{nrow(hist.df)<=2/delta}, perturbed histogram algorithm is from:
#' Karwa, V. and Vadhan, S. (2017). Finite sample differentially private confidence intervals.
#'
#' When \code{delta>0} and \code{nrow(hist.df)>2/delta}, perturbed histogram algorithm is from:
#' Bun, M., Nissim, K., and Stemmer, U. (2016). Simultaneous private learning of multiple
#' concepts. In Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science,
#' ITCS ’16, page 369–380, New York, NY, USA. Association for Computing Machinery.
#'
#'
#' @family syntheticData
#' @importFrom VGAM rlaplace
#' @importFrom stats rbinom rgamma
#' @noRd


dp_perturbed_hist<-function(hist.df,epsilon,delta=0,possible.combos=NULL,quietly=T,sensitivity.multiplier=2){


  # san.props is sanitized proportions of observed rows,
  # missing.combos is count of unobserved possible combinations
  # epsilon is privacy parameter
  # nobs is number of rows in confidential data
  # rseed sets the random seed if !=NA
  # if quiet==F, then message about unobserved rows sampled is printed.
  gen_unrealized=function(san.props,missing.combos,threshold=0,epsilon,nobs,rseed=NA,quiet=quietly,sens.mult=sensitivity.multiplier){
    if(is.na(rseed)==FALSE){
      set.seed(rseed)
    }
    sc.param=(1/(nobs*epsilon))*sens.mult
    p.above.threshold=VGAM::plaplace(threshold,0,scale=sc.param,lower.tail=F)
    rcount.above.threshold=stats::rbinom(1,missing.combos,p.above.threshold)
    sumexp=stats::rgamma(1,rcount.above.threshold,1/sc.param)+(threshold*rcount.above.threshold)
    p.select.unobserved=sumexp/(sum(san.props[san.props>threshold])+sumexp)
    rcount.select.unobserved=stats::rbinom(1,nobs,p.select.unobserved)
    #rcount.select.observed=nobs-rcount.select.unobserved
    if(quiet==F){
    message(paste("Number of unobserved rows selected is:",rcount.select.unobserved))
    }
    return(list("count.unobs.sampled"=rcount.select.unobserved,"normalizer"=sum(san.props[san.props>threshold])+sumexp+(threshold*rcount.above.threshold)))
  }

  ## Approximate DP perturbed histogram
  dp_perturbed_hist_approxDP<-function(hist.df,epsilon,delta,K,quietly=T,sensitivity.multiplier=2){
    if(K>(2/delta)){#Use Bun et al., 2016
      nobs=sum(hist.df$Freq,na.rm=T)
      num.bins=base::nrow(hist.df) #number of bins
      hist.df$san.prop=hist.df$Freq/nobs
      indic.zeros=ifelse(hist.df$san.prop==0,T,F)
      threshold=((2*base::log(2/delta))/(epsilon/nobs))+(1/nobs)
      #add laplace noise
      hist.df$san.prop=(hist.df$san.prop+
                          VGAM::rlaplace(nrow(hist.df),0,scale=sensitivity.multiplier*(1/(nobs*epsilon))))

      hist.df$san.prop[indic.zeros]=0
      hist.df$san.prop[hist.df$san.prop<=threshold]=0
      #normalize
      hist.df$san.prop=hist.df$san.prop/sum(hist.df$san.prop,na.rm=T)
      return(hist.df)
    }else{
      stop(paste0("K=",K,"not larger than 2/delta=",round(2/delta,3)," thus Bun et al., 2016 Histogram Learner cannot be used."))
    }

  }


  if(delta>0){#approximate DP
    if(is.null(possible.combos)==TRUE){
      message("No possible.combos provided. It is assumed all potential combinations of variables are represented in hist.df.")
      possible.combos=base::nrow(hist.df)
    }
    hist.df=dp_perturbed_hist_approxDP(hist.df=hist.df,epsilon=epsilon,delta=delta,K=nrow(hist.df),quietly=quietly,sensitivity.multiplier=sensitivity.multiplier)
    #hist.df$san.prop=hist.df$san.prop/sum(hist.df$san.prop)
    count.unobs.rows=0
    used.sanprop.add=F
  }else{
    if(is.null(possible.combos)==TRUE){
      message("No possible.combos provided. It is assumed all potential combinations of variables are represented in hist.df.")
      possible.combos=base::nrow(hist.df)
    }
    used.sanprop.add=T
    missing.combos=possible.combos-nrow(hist.df)
    nobs=sum(hist.df$Freq,na.rm=T)
    num.bins=base::nrow(hist.df) #number of bins
    hist.df$san.prop=hist.df$Freq/nobs
    #add laplace noise
    hist.df$san.prop=(hist.df$san.prop+
                        VGAM::rlaplace(num.bins,0,scale=sensitivity.multiplier*(1/(nobs*epsilon))))

    hist.df$san.prop=pmax(hist.df$san.prop,0)
    sc.param=1/(nobs*epsilon)
    out=gen_unrealized(san.props=hist.df$san.prop, missing.combos = missing.combos,
                                       threshold=0,nobs=nobs,epsilon=epsilon)
    count.unobs.rows=out[[1]]
    normalizer=out[[2]]
  }

  if(used.sanprop.add==TRUE){
    #print("in used.sanprop.add==TRUE")
    #total=(sum(hist.df$san.prop)+sum(sanprop.zero.to.add))
    #hist.df$san.prop=hist.df$san.prop/total #normalize
    #sanprop.zero.to.add=sanprop.zero.to.add/total
    return(list("hist.df"=hist.df,"count.unobs.rows.sampled"=count.unobs.rows,"normalizing constant"=normalizer))
  }else{
    return(hist.df)
  }
  }






# gen_unrealized=function(missing.combos,threshold,sc.param,rseed=NA){
#   if(is.na(rseed)==FALSE){
#     set.seed(rseed)
#   }
#   # count.threshold=nobs*threshold
#   # if((1/epsilon)<1){
#   #   message("epsilon is such that the discrete laplace mechanism can be used")
#   #   p.above=extraDistr::::pdlaplace(count.threshold,mu=0, scale=(1/epsilon),lower.tail=F)
#   # }else{
#   #   message("epsilon is such that the discrete laplace mechanism can not be used")
#   #   p.above=extraDistr::::pdlaplace(count.threshold,mu=0, scale=(1/epsilon),lower.tail=F)
#   # }
#   p.above=1-VGAM::plaplace(threshold,scale=sc.param,lower.tail = T)
#   rcount.above.threshold=rbinom(1,missing.combos,p.above)
#   print(paste("The rcount is",rcount.above.threshold,"and missing combos is",missing.combos))
#   if(rcount.above.threshold>0){
#     unif.prob1=stats::runif(rcount.above.threshold%/%4,p.above,1)
#     unif.prob2=stats::runif(rcount.above.threshold%/%4,p.above,1)
#     unif.prob3=stats::runif(rcount.above.threshold%/%4,p.above,1)
#     unif.prob4=stats::runif(rcount.above.threshold-(3*(rcount.above.threshold%/%4)),p.above,1)
#     san.prop1=VGAM::qlaplace(unif.prob1,0,scale=sc.param,lower.tail=T)
#     san.prop2=VGAM::qlaplace(unif.prob2,0,scale=sc.param,lower.tail=T)
#     san.prop3=VGAM::qlaplace(unif.prob3,0,scale=sc.param,lower.tail=T)
#     san.prop4=VGAM::qlaplace(unif.prob4,0,scale=sc.param,lower.tail=T)
#
#     return(c(san.prop1,san.prop2,san.prop3,san.prop4))
#   }else{
#     return(NULL)
#   }
# }
#


