#' Generate sanitized proportions that satisfy (epsilon,delta)-DP
#'
#' @param hist.df a data.frame of the counts for the number of occurrences of a category (or combination of categories) which is column \code{hist.df$Freq}vector of continuous values to be split into bins
#' @param epsilon a positive privacy parameter value
#' @param delta a non-negative value for a privacy parameter. If \code{nrow(hist.df)<=}
#' @return a data.frame which is the hist.df with column \code{hist.df$san.prop} which is a sanitized proportion of the data that is in a bin which is generated by a Laplace mechanism satisfying (\code{epsilon},\code{delta})-differential privacy.
#'
#' @examples
#' freq.df=multivariate_histogram(mtcars[,2:4],continuous.vars=c("disp","hp"),num.bin=3)
#' dp_perturbed_hist(freq.df,0.9,delta=0.01)
#'
#' @references
#' When \code{delta==0} or \code{nrow(hist.df)<=2/delta}, perturbed histogram algorithm is from:
#' Karwa, V. and Vadhan, S. (2017). Finite sample differentially private confidence intervals.
#'
#' When \code{delta>0} and \code{nrow(hist.df)>2/delta}, perturbed histogram algorithm is from:
#' Bun, M., Nissim, K., and Stemmer, U. (2016). Simultaneous private learning of multiple
#' concepts. In Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science,
#' ITCS ’16, page 369–380, New York, NY, USA. Association for Computing Machinery.
#'
#'
#' @family syntheticData
#' @importFrom VGAM rlaplace
#' @export


dp_perturbed_hist<-function(hist.df,epsilon,delta=0){

###NOTE:: THIS IS CURRENTLY NOT CORRECT FOR delta>0. I will fix it
  hist.df=hist.df[hist.df$Freq>0,,drop=F] #remove bins with 0 counts
  n=base::sum(hist.df$Freq) #number of observations
  num.bins=base::nrow(hist.df) #number of bins
  hist.df$san.prop=hist.df$Freq/n

  bins.pos=hist.df$san.prop>0

  #add laplace noise
  hist.df$san.prop[bins.pos]=(hist.df$san.prop[bins.pos]+
                                VGAM::rlaplace(sum(bins.pos),0,2/(n*epsilon)))

  #if using delta>0, and number of bins is high enough
  if((delta>0)&(num.bins>(2/delta))){ #use Bun et al. 2016
    threshold=((2*base::log(2/delta))/(epsilon/n))+(1/n)
  }else{ #pure-DP and low number of bins don't use a threshold
    threshold=0
  }
  hist.df$san.prop=base::pmax(hist.df$san.prop,threshold)
  hist.df$san.prop=hist.df$san.prop/(sum(hist.df$san.prop)) #normalize
  return(hist.df)
}
